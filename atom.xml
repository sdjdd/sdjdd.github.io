<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.sdjdd.com/"/>
  <updated>2019-06-23T12:10:32.487Z</updated>
  <id>https://blog.sdjdd.com/</id>
  
  <author>
    <name>sdjdd</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为什么我们改用 gRPC</title>
    <link href="https://blog.sdjdd.com/2019/06/22/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E6%94%B9%E7%94%A8-gRPC/"/>
    <id>https://blog.sdjdd.com/2019/06/22/为什么我们改用-gRPC/</id>
    <published>2019-06-22T08:34:38.000Z</published>
    <updated>2019-06-23T12:10:32.487Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://eng.fromatob.com/post/2019/05/why-were-switching-to-grpc/" target="_blank" rel="noopener">Why We’re Switching to gRPC</a></p></blockquote><p>本文由 <a href="https://github.com/lfritz" target="_blank" rel="noopener">Levin Fritz</a> 于2019年5月27日发布。</p><p>当你使用微服务架构时，你需要做一个非常基本的决定：你的服务之间如何互相通信？默认的选择似乎是通过 HTTP 发送 JSON ——使用所谓的 REST APIs，尽管大多数人并不认真对待 REST 原则。在 fromAtoB 我们就是这么开始的。但最近我们决定将 gRPC 作为我们的标准。</p><p><a href="https://grpc.io/" target="_blank" rel="noopener">gRPC</a> 是由谷歌开发的远程过程调用系统，现已开源。尽管它已经存在了很多年，但我很少在网上看到关于为什么人们使用或不使用它的信息，所以我决定写一篇文章来解释我们使用 gRPC 的原因。</p><p>gRPC 的一个显著优势是它使用了一种高效的二进制编码，这使它比 JSON/HTTP 更快。虽然越快越好，但对我们来说有两个方面更为重要：清晰的接口规范和对流的支持。</p><h2 id="gRPC-接口规范"><a href="#gRPC-接口规范" class="headerlink" title="gRPC 接口规范"></a>gRPC 接口规范</h2><p>当你创建一个新的 gRPC 服务时，第一步始终是在一个 <code>.proto</code> 文件中定义接口。下面的代码展示了它的样子——它是我们一小部分 API 的简化版本。该示例定义了一个远程过程调用 “Lookup” 和其输入输出的类型。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> fromatob;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FromAtoB 是 fromAtoB 后端 API 的简化版本。</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">FromAtoB</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Lookup(LookupRequest) <span class="keyword">returns</span> (Coordinate) &#123;&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// LookupRequest 是一个按名称查找城市坐标的请求。</span></span><br><span class="line"><span class="function">message LookupRequest &#123;</span></span><br><span class="line"><span class="function">string name = 1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Coordinate 坐标通过经纬度来确定地球上的位置。</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Coordinate</span> </span>&#123;</span><br><span class="line"><span class="comment">// Latitude 是位置的纬度，范围是 [-90, 90]。</span></span><br><span class="line"><span class="built_in">double</span> latitude = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Longitude 是位置的经度，范围是 [-180, 180]。</span></span><br><span class="line"><span class="built_in">double</span> longitude = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个文件，你可以用 <code>protoc</code> 编译器生成客户端和服务器代码，并开始编写提供或使用 API 的代码。</p><p>所以，为什么这是件好事而不仅仅是额外工作呢？再看一眼上面的示例代码。即使你从未使用过 gRPC 或 Protocol Buffers，它也非常易读：例如，很明显，要发送 <code>Lookup</code> 请求，你应该发送一个 <code>name</code>（一个字符串），然后得到一个 <code>Coordinate</code>（由 <code>latitude</code> 和 <code>longitude</code> 组成）。事实上，你可以像本示例一样通过添加一些简单的注释，将 <code>.proto</code> 文件变成 API 服务的文档。</p><p>当然，真实服务的规格要大得多，但不会复杂的多。不过就是多为方法提供些 <code>rpc</code> 声明，为数据类型提供些 <code>message</code> 声明。</p><p>通过 <code>protoc</code> 生成的代码还确保客户端或服务器发送的数据符合规范。这为调试提供了很大的帮助。我记得有两次，我正在处理生成错误格式的 JSON 数据的服务，因为该格式没在任何地方做验证，所以问题只出现在了用户界面。找出问题的唯一方式就是调试前端 JavaScript 代码——这对从来没用过前端 JavaScript 框架的后端工程师来说绝非易事！</p><h2 id="Swagger-OpenAPI"><a href="#Swagger-OpenAPI" class="headerlink" title="Swagger / OpenAPI"></a>Swagger / OpenAPI</h2><p>原则上，通过使用 <a href="https://swagger.io/" target="_blank" rel="noopener">Swagger</a> 或 <a href="https://www.openapis.org/" target="_blank" rel="noopener">OpenAPI</a>，HTTP/JSON 也可以获得同样的优点。这有个和上面 gRPC API 等效的示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">openapi:</span> <span class="number">3.0</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">info:</span></span><br><span class="line"><span class="attr">  title:</span> <span class="string">fromAtoB</span> <span class="string">后端</span> <span class="string">API</span> <span class="string">的简化版本</span></span><br><span class="line"><span class="attr">  version:</span> <span class="string">'1.0'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">paths:</span></span><br><span class="line">  <span class="string">/lookup:</span></span><br><span class="line"><span class="attr">    get:</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">按名称查找城市坐标。</span></span><br><span class="line"><span class="attr">      parameters:</span></span><br><span class="line"><span class="attr">        - in:</span> <span class="string">query</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">name</span></span><br><span class="line"><span class="attr">          schema:</span></span><br><span class="line"><span class="attr">            type:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">          description:</span> <span class="string">City</span> <span class="string">name.</span></span><br><span class="line"><span class="attr">      responses:</span></span><br><span class="line">        <span class="string">'200'</span><span class="string">:</span></span><br><span class="line"><span class="attr">          description:</span> <span class="string">OK</span></span><br><span class="line"><span class="attr">          content:</span></span><br><span class="line">            <span class="string">application/json:</span></span><br><span class="line"><span class="attr">              schema:</span></span><br><span class="line">                <span class="string">$ref:</span> <span class="string">'#/components/schemas/Coordinate'</span></span><br><span class="line">        <span class="string">'404'</span><span class="string">:</span></span><br><span class="line"><span class="attr">          description:</span> <span class="string">Not</span> <span class="string">Found</span></span><br><span class="line"><span class="attr">          content:</span></span><br><span class="line">            <span class="string">text/plain:</span></span><br><span class="line"><span class="attr">              schema:</span></span><br><span class="line"><span class="attr">                type:</span> <span class="string">string</span></span><br><span class="line"></span><br><span class="line"><span class="attr">components:</span></span><br><span class="line"><span class="attr">  schemas:</span></span><br><span class="line"><span class="attr">    Coordinate:</span></span><br><span class="line"><span class="attr">      type:</span> <span class="string">object</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">Coordinate</span> <span class="string">坐标通过经纬度来确定地球上的位置。</span></span><br><span class="line"><span class="attr">      properties:</span></span><br><span class="line"><span class="attr">        latitude:</span></span><br><span class="line"><span class="attr">          type:</span> <span class="string">number</span></span><br><span class="line"><span class="attr">          description:</span> <span class="string">Latitude</span> <span class="string">是位置的纬度，范围是</span> <span class="string">[-90,</span> <span class="number">90</span><span class="string">]。</span></span><br><span class="line"><span class="attr">        longitude:</span></span><br><span class="line"><span class="attr">          type:</span> <span class="string">number</span></span><br><span class="line"><span class="attr">          description:</span> <span class="string">Longitude</span> <span class="string">是位置的经度，范围是</span> <span class="string">[-180,</span> <span class="number">180</span><span class="string">]。</span></span><br></pre></td></tr></table></figure><p>将其与上面 gRPC 的规范进行比较。OpenAPI 的易读性更差！它更冗长，结构也更复杂（8个缩进级别，gRPC 只有1个）。</p><p>使用 OpenAPI 规范进行验证也比使用 gRPC 更困难。至少对内部服务来说，这意味着要么根本没写，要么跟不上 API 的发展而变得无用。</p><h2 id="Streaming"><a href="#Streaming" class="headerlink" title="Streaming"></a>Streaming</h2><p>今年早些时候，我开始为我们的搜索设计新的 API（比如“获取2019年6月1日从柏林到巴黎的所有连接”）。我用 HTTP 和 JSON 构建了第一版 API 之后，我的一位同事指出某些情况下我们需要流式传输结果，这意味着我们应该在得到第一个结果的同时把他们发送出去。我的 API 仅仅返回一个 JSON 数组，所以在集齐所有结果之前，服务器不会发送任何数据。</p><p>我们通过在前端轮询的方式使用 API 。通过发送 POST 请求的方式设置搜索，然后发送重复的 GET 请求检索结果。响应中包含指示搜索是否完成的字段。这么做可行，但不是特别优雅，它需要服务器使用 Redis 之类的来存储中间结果。新的 API 将由多个更小的服务实现，我不想强制它们实现此逻辑。</p><p>这时我们准备尝试 gRPC 。要用 gRPC 发送远程过程调用的结果，只需在 <code>.proto</code> 文件中添加 <code>stream</code> 关键字。以下是 <code>Search</code> 函数的定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">rpc</span> Search (SearchRequest) <span class="keyword">returns</span> (stream Trip) &#123;&#125;</span></span><br></pre></td></tr></table></figure><p><code>protoc</code> 编译器生成的代码包含一个具有 <code>Send</code> 函数的对象和一个具有 <code>Recv</code> 函数的对象，我们的服务器代码通过调用 <code>Send</code> 该函数逐一发送 <code>Trip</code> 对象，客户端代码通过调用 <code>Recv</code> 函数来检索它们。从程序员的角度来看，这比实现轮询 API 要容易的多。</p><h2 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h2><p>我想提一些 gRPC 的缺点。它们都和工具有关，而不是协议本身。</p><p>当使用 HTTP/JSON 构建 API 时，可以使用 curl 、httpie 或 Postman 进行简单的手动测试。gRPC 也有一个类似的工具叫 <a href="https://github.com/fullstorydev/grpcurl" target="_blank" rel="noopener">grpcurl</a> ，但它不是开箱即用的：你必须在服务器端添加 <a href="https://github.com/grpc/grpc/blob/master/doc/server-reflection.md" target="_blank" rel="noopener">gRPC server reflection</a> 扩展或为每个命令指定 <code>.proto</code> 文件。我们发现在服务器中添加一个小命令行工具可以更方便的发送简单请求。<code>protoc</code> 生成的客户端代码也使这非常简单。</p><p>对我们来说，更大的问题是我们在 HTTP 服务中使用的 Kubernetes 负载均衡器在 gRPC 中不能很好地工作。本质上，gRPC 要求在应用程序级别而不是 TCP 连接级别进行负载均衡。为了解决这个问题，我们按照这个教程：<a href="https://kubernetes.io/blog/2018/11/07/grpc-load-balancing-on-kubernetes-without-tears/" target="_blank" rel="noopener">gRPC Load Balancing on Kubernetes without Tears</a> 设置了 <a href="https://linkerd.io/" target="_blank" rel="noopener">Linkerd</a>。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>尽管构建 gRPC API 需要多做一点前期工作，但我们发现具有明确的 API 规范和对流式传输的良好支持可以弥补这一点。对我们来说，gRPC 将成为我们构建的任何新的内部服务的默认选项。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://eng.fromatob.com/post/2019/05/why-were-switching-to-grpc/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Why We’re Sw
      
    
    </summary>
    
      <category term="翻译" scheme="https://blog.sdjdd.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="gRPC" scheme="https://blog.sdjdd.com/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>JSON 配置文件的缺点</title>
    <link href="https://blog.sdjdd.com/2019/06/16/JSON-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%BA%E7%82%B9/"/>
    <id>https://blog.sdjdd.com/2019/06/16/JSON-配置文件的缺点/</id>
    <published>2019-06-16T05:11:46.000Z</published>
    <updated>2019-06-16T16:53:59.849Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://arp242.net/json-config.html" target="_blank" rel="noopener">The downsides of JSON for config files</a></p></blockquote><p>我近期目睹了使用 JSON 作为配置文件的趋势，我认为这不是一个好主意。</p><p>这不是 JSON 的设计目的，因此它不擅长做这件事。JSON 旨在成为一种“轻量数据交换格式”，并声称其“易于人类读写”和“易于机器解析和生成”。</p><p>作为一种数据交换格式，JSON 相当不错。人类可以相对容易地读写它，而且机器解析起来也很容易（尽管存在<a href="http://seriot.ch/parsing_json.php" target="_blank" rel="noopener">一些问题</a>）。</p><p>这是一个良好的在机器可读和人类可读之间的权衡，对于许多用例来说，这是对 XML 的一个很好的改进。</p><p>将其用于其它目的有些类似于：“嘿，这把锤子非常适合用来钉钉子！我很中意它！为什么不用它来敲这颗螺丝呢！”。当然，这么做也可以，但它不是正确的工具。</p><hr><p>截止到目前，最大的问题是你无法添加注释。少数 JSON 解析器可以，但大多数都不支持，它也不在标准中。有充分的理由关于<a href="https://web.archive.org/web/20120506232618/https://plus.google.com/118095276221607585885/posts/RK8qyGVaGSr" target="_blank" rel="noopener">明确从 JSON 中移除</a>注释。</p><p>你想要添加注释的原因有很多：记录为什么设置成该值，添加助记符或描述警告，警告过去的配置错误，在其中保留一个基本的更改日志，或者单纯是为了在调试时注释掉某个段落或值。</p><p>一个<a href="http://stackoverflow.com/a/244858/660921" target="_blank" rel="noopener">变通方法</a>是添加一个新的键（如 <code>{&quot;__comment&quot;: &quot;a comment&quot;, &quot;actual_data&quot;: &quot;...&quot;}</code>，但我觉得这实在是太难看了)。</p><p>你也可以使用提交日志，但是谁会在提交历史中不大可能隐藏一些重要信息的情况下去仔细阅读它呢？</p><p>一些 JSON 方言例如 JSON5，Hjson 和 HOCON 添加了对注释的支持，一些 JSON 解析器也是如此。这很好，我也鼓励你去使用它，但这不再是 JSON 了，而是 JSON 方言。这篇文章是关于 JSON 的，不是它的方言。</p><hr><p>我还发现在手动编辑 JSON 时的体验很不理想，你需要频繁的追加逗号，引号的语义非常烦人，而且它缺乏使用多行字符串的能力。这些属性适用于 JSON 的预期用途，但不太适合编写配置文件。它可行吗？当然。有趣吗？不。</p><p>我也没觉得它特别易读，因为它包含过多的引号和其它语法噪音。我坦率承认这可能是我的品位问题。</p><hr><p>JSON 是一种声明性配置语言。声明性配置（DC）适用于某些问题，但其它问题就不那么适用了。尤其是使用 DC 来控制逻辑，通常不是个好主意。</p><p>促使我写这篇文章的是 MediaWiki 的新扩展系统，旧系统使用一个简单的 PHP 文件来连接核心 MediaWiki 代码，加载所需依赖等。这些在新系统中被一个 JSON 文件替换。丧失了巧妙解决与其它插件或逻辑的兼容问题的能力。</p><p>它实现起来也很复杂，以前只需要 <code>require(&#39;plugin/foo/plugin.php&#39;);</code>，现在它需要解析一个 JSON 文件，并根据其内容做些什么。这要复杂得多，因此也<a href="https://arp242.net/easy.html" target="_blank" rel="noopener">难以测试</a>。</p><p>而使用 JSON 文件存储基本的元数据是有意义的（更容易在网站上解析和显示），用它来描述代码的工作方式对于我来说是对 DC 的滥用。毕竟这是代码的活儿。</p><hr><p>很多人向我征求关于使用什么的建议。这不是个容易回答的问题，因为它取决于你的用例，编程语言，库环境和社会因素。没有单一的“正确答案”，也许只有“最简单的，满足你所有需求”的答案。事实上我写了<a href="https://arp242.net/negative-argument.html" target="_blank" rel="noopener">一篇关于这一点的文章</a>。</p><p>一个很好的选项可能是只<a href="https://arp242.net/flags-config.html" target="_blank" rel="noopener">使用命令行标志</a>。</p><p>有一些 JSON 方言专为人类编写而设计：<a href="https://json5.org/" target="_blank" rel="noopener">JSON5</a>，<a href="http://hjson.org/" target="_blank" rel="noopener">Hjson</a> 和 <a href="https://github.com/lightbend/config/blob/master/HOCON.md" target="_blank" rel="noopener">HOCON</a>。所有这些似乎都是对标准 JSON 的合理改进，尽管我没有用过它们中的任何一个。特别是 JSON5 似乎是个不错的选项，因为它对 JSON 的改动最少。</p><p>我不愿提供其它选项，因为我没有对所有格式（ <a href="https://arp242.net/yaml-config.html" target="_blank" rel="noopener">YAML</a> 除外）进行深入评估；只是看看规范可能无法找出潜在的缺点（ YAML 就是个很好的例子，它有很多微妙的行为）。我确实没有时间或是兴趣去对所有选项做全面深入的审查。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://arp242.net/json-config.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The downsides of JSON for config files&lt;/a&gt;
      
    
    </summary>
    
      <category term="翻译" scheme="https://blog.sdjdd.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="JSON" scheme="https://blog.sdjdd.com/tags/JSON/"/>
    
  </entry>
  
</feed>
