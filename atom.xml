<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.sdjdd.com/"/>
  <updated>2019-06-30T09:04:05.842Z</updated>
  <id>https://blog.sdjdd.com/</id>
  
  <author>
    <name>sdjdd</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我不想成为一个全栈开发者</title>
    <link href="https://blog.sdjdd.com/2019/06/30/%E6%88%91%E4%B8%8D%E6%83%B3%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%E8%80%85/"/>
    <id>https://blog.sdjdd.com/2019/06/30/我不想成为一个全栈开发者/</id>
    <published>2019-06-30T04:32:04.000Z</published>
    <updated>2019-06-30T09:04:05.842Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://artur-martsinkovskyi.github.io//2019/i-dont-want-to-be-fullstack/" target="_blank" rel="noopener">I don’t want to be a full-fullstack developer</a><br>译注：我很同意这为乌克兰开发者的观点，但他的英文水平实在是一言难尽。</p></blockquote><p>我是一名 Ruby 开发者，一个全站 web 开发者。对此我深感疲惫，厌倦了有时负责商业分析和手册的质量保证。随着时间的推移，这个行业越来越多的依靠以开发人员为中心的工作流程，开发者们将越来越多的工作交由同一个人负责。</p><h2 id="很久以前的互联网"><a href="#很久以前的互联网" class="headerlink" title="很久以前的互联网"></a>很久以前的互联网</h2><p>很久以前就有 DBA ，但现在几乎看不到了。在 Indeed.com 中<a href="https://www.indeed.com/jobs?q=full+stack+web+developer&l=" target="_blank" rel="noopener">搜索</a> <em>全栈开发者</em> 会得到 7000 个结果，<em>web 开发者</em> 的搜索结果有 40000 个。用户体验工程师和前端开发者的角色也在工作内容基本一致的前提下慢慢融合。越来越多的代理机构开始寻找既能做前端也能做后端的人，既能参与业务需求开发也能编写单元测试和集成测试的人，希望他们无所不在，无所不能。</p><h2 id="削减成本"><a href="#削减成本" class="headerlink" title="削减成本"></a>削减成本</h2><p>乍一看，这似乎是个好主意，有人知道从开发到发布所需的一切，掌控整个过程。这对企业来说更加容易：你只需和一个人进行核对，开发过程不会因为“谁做什么”的问题而变得特别复杂。这么做还能降低成本，在质量和开发时间中作出一点权衡。沟通也变得更加顺畅了，和一个经历了整个开发流程的人交流要比沿着流程链挨个询问要容易得多。这听起来很不错，如果你不知道把这么多专业工作全都塞给一个人去做会发生什么的话。</p><h2 id="复杂性的回击"><a href="#复杂性的回击" class="headerlink" title="复杂性的回击"></a>复杂性的回击</h2><p>后端开发是个复杂的领域，包括理解网络层、服务器的整体工作方式、部署、AWS/Google/Azure 服务（它们对现代 web 应用至关重要）、编程语言和框架的细节，使用的协议、身份认证、数据库连接和配置等。前端包括过硬的 web 标准知识、浏览器间的差异、ES5、ES6、CSS、HTML、框架、预处理器、转换器、构建工具、UX、UI、浏览器角度的网络、浏览器存储，有时甚至包括 Flutter、Ionic 和 React Native 之类的移动端应用的细节。我不想讨论业务分析师和 QA 的角色，它们完全是不同的概念。</p><h2 id="宽度还是广度？"><a href="#宽度还是广度？" class="headerlink" title="宽度还是广度？"></a>宽度还是广度？</h2><p>别误会，我认为扩大知识领域并通过对周边技术的理解更好的完成所在部门的工作是件好事。但不论行业，让开发者直接负责代码质量、选择解决方案以及项目开发的未来规划未必是件好事。我们大脑的空间是有限的。我们可以用一个或少数几个领域的更深更好的知识来填充它，或是多个领域的肤浅的知识。后者制造了一种虚假的自信，从而导致选择糟糕的解决方案，造轮子、选错技术、用显微镜敲钉子。</p><h2 id="并非所有削减都是好的"><a href="#并非所有削减都是好的" class="headerlink" title="并非所有削减都是好的"></a>并非所有削减都是好的</h2><p>全栈很有趣，因为它似乎只存在于软件工程领域。其他领域大多都分工明确。你不会希望让牙医来治疗你的心脏，让神经外科医生来修复你的痔疮。它被用于软件工程似乎是由该领域的虚拟和故障安全特性。你的代码质量不会直接影响用户可见的结果，因此你在事情变糟之前有足够的时间处理（这种情况在你不在的时候常常出现）。此外，这个想法似乎对直观的金钱花销很有吸引力，雇佣拥有广泛技能（无论质量）的人可能看上去是在用同样的钱做更多的事。</p><p>我们得到的平庸的解决方案都是由那些在特定领域没有足够的专业知识，无法找出更好的方案的人提出的，他们粗略的知识中满是 Stackoverflow 的答案和复制粘贴来的东西。我们让那些不思进取的人不得不跟上太多主题，让那些专业人士无法创造出惊人的东西，因为他们没有足够的时间深究并创造出对该领域有价值的东西。在开发过程中不可避免的会遇到各种问题，导致 bug 和用户流失，影响开发成本，使我们以低廉的价格开发出不合格的产品。从短期经济角度来看，全栈可能是值得的，但它对整个行业和我们建设的项目都有害。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://artur-martsinkovskyi.github.io//2019/i-dont-want-to-be-fullstack/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;I do
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>为什么我们改用 gRPC</title>
    <link href="https://blog.sdjdd.com/2019/06/22/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E6%94%B9%E7%94%A8-gRPC/"/>
    <id>https://blog.sdjdd.com/2019/06/22/为什么我们改用-gRPC/</id>
    <published>2019-06-22T08:34:38.000Z</published>
    <updated>2019-06-23T12:10:32.487Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://eng.fromatob.com/post/2019/05/why-were-switching-to-grpc/" target="_blank" rel="noopener">Why We’re Switching to gRPC</a></p></blockquote><p>本文由 <a href="https://github.com/lfritz" target="_blank" rel="noopener">Levin Fritz</a> 于2019年5月27日发布。</p><p>当你使用微服务架构时，你需要做一个非常基本的决定：你的服务之间如何互相通信？默认的选择似乎是通过 HTTP 发送 JSON ——使用所谓的 REST APIs，尽管大多数人并不认真对待 REST 原则。在 fromAtoB 我们就是这么开始的。但最近我们决定将 gRPC 作为我们的标准。</p><p><a href="https://grpc.io/" target="_blank" rel="noopener">gRPC</a> 是由谷歌开发的远程过程调用系统，现已开源。尽管它已经存在了很多年，但我很少在网上看到关于为什么人们使用或不使用它的信息，所以我决定写一篇文章来解释我们使用 gRPC 的原因。</p><p>gRPC 的一个显著优势是它使用了一种高效的二进制编码，这使它比 JSON/HTTP 更快。虽然越快越好，但对我们来说有两个方面更为重要：清晰的接口规范和对流的支持。</p><h2 id="gRPC-接口规范"><a href="#gRPC-接口规范" class="headerlink" title="gRPC 接口规范"></a>gRPC 接口规范</h2><p>当你创建一个新的 gRPC 服务时，第一步始终是在一个 <code>.proto</code> 文件中定义接口。下面的代码展示了它的样子——它是我们一小部分 API 的简化版本。该示例定义了一个远程过程调用 “Lookup” 和其输入输出的类型。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> fromatob;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FromAtoB 是 fromAtoB 后端 API 的简化版本。</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">FromAtoB</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Lookup(LookupRequest) <span class="keyword">returns</span> (Coordinate) &#123;&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// LookupRequest 是一个按名称查找城市坐标的请求。</span></span><br><span class="line"><span class="function">message LookupRequest &#123;</span></span><br><span class="line"><span class="function">string name = 1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Coordinate 坐标通过经纬度来确定地球上的位置。</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Coordinate</span> </span>&#123;</span><br><span class="line"><span class="comment">// Latitude 是位置的纬度，范围是 [-90, 90]。</span></span><br><span class="line"><span class="built_in">double</span> latitude = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Longitude 是位置的经度，范围是 [-180, 180]。</span></span><br><span class="line"><span class="built_in">double</span> longitude = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个文件，你可以用 <code>protoc</code> 编译器生成客户端和服务器代码，并开始编写提供或使用 API 的代码。</p><p>所以，为什么这是件好事而不仅仅是额外工作呢？再看一眼上面的示例代码。即使你从未使用过 gRPC 或 Protocol Buffers，它也非常易读：例如，很明显，要发送 <code>Lookup</code> 请求，你应该发送一个 <code>name</code>（一个字符串），然后得到一个 <code>Coordinate</code>（由 <code>latitude</code> 和 <code>longitude</code> 组成）。事实上，你可以像本示例一样通过添加一些简单的注释，将 <code>.proto</code> 文件变成 API 服务的文档。</p><p>当然，真实服务的规格要大得多，但不会复杂的多。不过就是多为方法提供些 <code>rpc</code> 声明，为数据类型提供些 <code>message</code> 声明。</p><p>通过 <code>protoc</code> 生成的代码还确保客户端或服务器发送的数据符合规范。这为调试提供了很大的帮助。我记得有两次，我正在处理生成错误格式的 JSON 数据的服务，因为该格式没在任何地方做验证，所以问题只出现在了用户界面。找出问题的唯一方式就是调试前端 JavaScript 代码——这对从来没用过前端 JavaScript 框架的后端工程师来说绝非易事！</p><h2 id="Swagger-OpenAPI"><a href="#Swagger-OpenAPI" class="headerlink" title="Swagger / OpenAPI"></a>Swagger / OpenAPI</h2><p>原则上，通过使用 <a href="https://swagger.io/" target="_blank" rel="noopener">Swagger</a> 或 <a href="https://www.openapis.org/" target="_blank" rel="noopener">OpenAPI</a>，HTTP/JSON 也可以获得同样的优点。这有个和上面 gRPC API 等效的示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">openapi:</span> <span class="number">3.0</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">info:</span></span><br><span class="line"><span class="attr">  title:</span> <span class="string">fromAtoB</span> <span class="string">后端</span> <span class="string">API</span> <span class="string">的简化版本</span></span><br><span class="line"><span class="attr">  version:</span> <span class="string">'1.0'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">paths:</span></span><br><span class="line">  <span class="string">/lookup:</span></span><br><span class="line"><span class="attr">    get:</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">按名称查找城市坐标。</span></span><br><span class="line"><span class="attr">      parameters:</span></span><br><span class="line"><span class="attr">        - in:</span> <span class="string">query</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">name</span></span><br><span class="line"><span class="attr">          schema:</span></span><br><span class="line"><span class="attr">            type:</span> <span class="string">string</span></span><br><span class="line"><span class="attr">          description:</span> <span class="string">City</span> <span class="string">name.</span></span><br><span class="line"><span class="attr">      responses:</span></span><br><span class="line">        <span class="string">'200'</span><span class="string">:</span></span><br><span class="line"><span class="attr">          description:</span> <span class="string">OK</span></span><br><span class="line"><span class="attr">          content:</span></span><br><span class="line">            <span class="string">application/json:</span></span><br><span class="line"><span class="attr">              schema:</span></span><br><span class="line">                <span class="string">$ref:</span> <span class="string">'#/components/schemas/Coordinate'</span></span><br><span class="line">        <span class="string">'404'</span><span class="string">:</span></span><br><span class="line"><span class="attr">          description:</span> <span class="string">Not</span> <span class="string">Found</span></span><br><span class="line"><span class="attr">          content:</span></span><br><span class="line">            <span class="string">text/plain:</span></span><br><span class="line"><span class="attr">              schema:</span></span><br><span class="line"><span class="attr">                type:</span> <span class="string">string</span></span><br><span class="line"></span><br><span class="line"><span class="attr">components:</span></span><br><span class="line"><span class="attr">  schemas:</span></span><br><span class="line"><span class="attr">    Coordinate:</span></span><br><span class="line"><span class="attr">      type:</span> <span class="string">object</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">Coordinate</span> <span class="string">坐标通过经纬度来确定地球上的位置。</span></span><br><span class="line"><span class="attr">      properties:</span></span><br><span class="line"><span class="attr">        latitude:</span></span><br><span class="line"><span class="attr">          type:</span> <span class="string">number</span></span><br><span class="line"><span class="attr">          description:</span> <span class="string">Latitude</span> <span class="string">是位置的纬度，范围是</span> <span class="string">[-90,</span> <span class="number">90</span><span class="string">]。</span></span><br><span class="line"><span class="attr">        longitude:</span></span><br><span class="line"><span class="attr">          type:</span> <span class="string">number</span></span><br><span class="line"><span class="attr">          description:</span> <span class="string">Longitude</span> <span class="string">是位置的经度，范围是</span> <span class="string">[-180,</span> <span class="number">180</span><span class="string">]。</span></span><br></pre></td></tr></table></figure><p>将其与上面 gRPC 的规范进行比较。OpenAPI 的易读性更差！它更冗长，结构也更复杂（8个缩进级别，gRPC 只有1个）。</p><p>使用 OpenAPI 规范进行验证也比使用 gRPC 更困难。至少对内部服务来说，这意味着要么根本没写，要么跟不上 API 的发展而变得无用。</p><h2 id="Streaming"><a href="#Streaming" class="headerlink" title="Streaming"></a>Streaming</h2><p>今年早些时候，我开始为我们的搜索设计新的 API（比如“获取2019年6月1日从柏林到巴黎的所有连接”）。我用 HTTP 和 JSON 构建了第一版 API 之后，我的一位同事指出某些情况下我们需要流式传输结果，这意味着我们应该在得到第一个结果的同时把他们发送出去。我的 API 仅仅返回一个 JSON 数组，所以在集齐所有结果之前，服务器不会发送任何数据。</p><p>我们通过在前端轮询的方式使用 API 。通过发送 POST 请求的方式设置搜索，然后发送重复的 GET 请求检索结果。响应中包含指示搜索是否完成的字段。这么做可行，但不是特别优雅，它需要服务器使用 Redis 之类的来存储中间结果。新的 API 将由多个更小的服务实现，我不想强制它们实现此逻辑。</p><p>这时我们准备尝试 gRPC 。要用 gRPC 发送远程过程调用的结果，只需在 <code>.proto</code> 文件中添加 <code>stream</code> 关键字。以下是 <code>Search</code> 函数的定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">rpc</span> Search (SearchRequest) <span class="keyword">returns</span> (stream Trip) &#123;&#125;</span></span><br></pre></td></tr></table></figure><p><code>protoc</code> 编译器生成的代码包含一个具有 <code>Send</code> 函数的对象和一个具有 <code>Recv</code> 函数的对象，我们的服务器代码通过调用 <code>Send</code> 该函数逐一发送 <code>Trip</code> 对象，客户端代码通过调用 <code>Recv</code> 函数来检索它们。从程序员的角度来看，这比实现轮询 API 要容易的多。</p><h2 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h2><p>我想提一些 gRPC 的缺点。它们都和工具有关，而不是协议本身。</p><p>当使用 HTTP/JSON 构建 API 时，可以使用 curl 、httpie 或 Postman 进行简单的手动测试。gRPC 也有一个类似的工具叫 <a href="https://github.com/fullstorydev/grpcurl" target="_blank" rel="noopener">grpcurl</a> ，但它不是开箱即用的：你必须在服务器端添加 <a href="https://github.com/grpc/grpc/blob/master/doc/server-reflection.md" target="_blank" rel="noopener">gRPC server reflection</a> 扩展或为每个命令指定 <code>.proto</code> 文件。我们发现在服务器中添加一个小命令行工具可以更方便的发送简单请求。<code>protoc</code> 生成的客户端代码也使这非常简单。</p><p>对我们来说，更大的问题是我们在 HTTP 服务中使用的 Kubernetes 负载均衡器在 gRPC 中不能很好地工作。本质上，gRPC 要求在应用程序级别而不是 TCP 连接级别进行负载均衡。为了解决这个问题，我们按照这个教程：<a href="https://kubernetes.io/blog/2018/11/07/grpc-load-balancing-on-kubernetes-without-tears/" target="_blank" rel="noopener">gRPC Load Balancing on Kubernetes without Tears</a> 设置了 <a href="https://linkerd.io/" target="_blank" rel="noopener">Linkerd</a>。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>尽管构建 gRPC API 需要多做一点前期工作，但我们发现具有明确的 API 规范和对流式传输的良好支持可以弥补这一点。对我们来说，gRPC 将成为我们构建的任何新的内部服务的默认选项。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://eng.fromatob.com/post/2019/05/why-were-switching-to-grpc/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Why We’re Sw
      
    
    </summary>
    
      <category term="翻译" scheme="https://blog.sdjdd.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="gRPC" scheme="https://blog.sdjdd.com/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>JSON 配置文件的缺点</title>
    <link href="https://blog.sdjdd.com/2019/06/16/JSON-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%BA%E7%82%B9/"/>
    <id>https://blog.sdjdd.com/2019/06/16/JSON-配置文件的缺点/</id>
    <published>2019-06-16T05:11:46.000Z</published>
    <updated>2019-06-16T16:53:59.849Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://arp242.net/json-config.html" target="_blank" rel="noopener">The downsides of JSON for config files</a></p></blockquote><p>我近期目睹了使用 JSON 作为配置文件的趋势，我认为这不是一个好主意。</p><p>这不是 JSON 的设计目的，因此它不擅长做这件事。JSON 旨在成为一种“轻量数据交换格式”，并声称其“易于人类读写”和“易于机器解析和生成”。</p><p>作为一种数据交换格式，JSON 相当不错。人类可以相对容易地读写它，而且机器解析起来也很容易（尽管存在<a href="http://seriot.ch/parsing_json.php" target="_blank" rel="noopener">一些问题</a>）。</p><p>这是一个良好的在机器可读和人类可读之间的权衡，对于许多用例来说，这是对 XML 的一个很好的改进。</p><p>将其用于其它目的有些类似于：“嘿，这把锤子非常适合用来钉钉子！我很中意它！为什么不用它来敲这颗螺丝呢！”。当然，这么做也可以，但它不是正确的工具。</p><hr><p>截止到目前，最大的问题是你无法添加注释。少数 JSON 解析器可以，但大多数都不支持，它也不在标准中。有充分的理由关于<a href="https://web.archive.org/web/20120506232618/https://plus.google.com/118095276221607585885/posts/RK8qyGVaGSr" target="_blank" rel="noopener">明确从 JSON 中移除</a>注释。</p><p>你想要添加注释的原因有很多：记录为什么设置成该值，添加助记符或描述警告，警告过去的配置错误，在其中保留一个基本的更改日志，或者单纯是为了在调试时注释掉某个段落或值。</p><p>一个<a href="http://stackoverflow.com/a/244858/660921" target="_blank" rel="noopener">变通方法</a>是添加一个新的键（如 <code>{&quot;__comment&quot;: &quot;a comment&quot;, &quot;actual_data&quot;: &quot;...&quot;}</code>，但我觉得这实在是太难看了)。</p><p>你也可以使用提交日志，但是谁会在提交历史中不大可能隐藏一些重要信息的情况下去仔细阅读它呢？</p><p>一些 JSON 方言例如 JSON5，Hjson 和 HOCON 添加了对注释的支持，一些 JSON 解析器也是如此。这很好，我也鼓励你去使用它，但这不再是 JSON 了，而是 JSON 方言。这篇文章是关于 JSON 的，不是它的方言。</p><hr><p>我还发现在手动编辑 JSON 时的体验很不理想，你需要频繁的追加逗号，引号的语义非常烦人，而且它缺乏使用多行字符串的能力。这些属性适用于 JSON 的预期用途，但不太适合编写配置文件。它可行吗？当然。有趣吗？不。</p><p>我也没觉得它特别易读，因为它包含过多的引号和其它语法噪音。我坦率承认这可能是我的品位问题。</p><hr><p>JSON 是一种声明性配置语言。声明性配置（DC）适用于某些问题，但其它问题就不那么适用了。尤其是使用 DC 来控制逻辑，通常不是个好主意。</p><p>促使我写这篇文章的是 MediaWiki 的新扩展系统，旧系统使用一个简单的 PHP 文件来连接核心 MediaWiki 代码，加载所需依赖等。这些在新系统中被一个 JSON 文件替换。丧失了巧妙解决与其它插件或逻辑的兼容问题的能力。</p><p>它实现起来也很复杂，以前只需要 <code>require(&#39;plugin/foo/plugin.php&#39;);</code>，现在它需要解析一个 JSON 文件，并根据其内容做些什么。这要复杂得多，因此也<a href="https://arp242.net/easy.html" target="_blank" rel="noopener">难以测试</a>。</p><p>而使用 JSON 文件存储基本的元数据是有意义的（更容易在网站上解析和显示），用它来描述代码的工作方式对于我来说是对 DC 的滥用。毕竟这是代码的活儿。</p><hr><p>很多人向我征求关于使用什么的建议。这不是个容易回答的问题，因为它取决于你的用例，编程语言，库环境和社会因素。没有单一的“正确答案”，也许只有“最简单的，满足你所有需求”的答案。事实上我写了<a href="https://arp242.net/negative-argument.html" target="_blank" rel="noopener">一篇关于这一点的文章</a>。</p><p>一个很好的选项可能是只<a href="https://arp242.net/flags-config.html" target="_blank" rel="noopener">使用命令行标志</a>。</p><p>有一些 JSON 方言专为人类编写而设计：<a href="https://json5.org/" target="_blank" rel="noopener">JSON5</a>，<a href="http://hjson.org/" target="_blank" rel="noopener">Hjson</a> 和 <a href="https://github.com/lightbend/config/blob/master/HOCON.md" target="_blank" rel="noopener">HOCON</a>。所有这些似乎都是对标准 JSON 的合理改进，尽管我没有用过它们中的任何一个。特别是 JSON5 似乎是个不错的选项，因为它对 JSON 的改动最少。</p><p>我不愿提供其它选项，因为我没有对所有格式（ <a href="https://arp242.net/yaml-config.html" target="_blank" rel="noopener">YAML</a> 除外）进行深入评估；只是看看规范可能无法找出潜在的缺点（ YAML 就是个很好的例子，它有很多微妙的行为）。我确实没有时间或是兴趣去对所有选项做全面深入的审查。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://arp242.net/json-config.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The downsides of JSON for config files&lt;/a&gt;
      
    
    </summary>
    
      <category term="翻译" scheme="https://blog.sdjdd.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="JSON" scheme="https://blog.sdjdd.com/tags/JSON/"/>
    
  </entry>
  
</feed>
